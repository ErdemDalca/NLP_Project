# Pixel Runner Game Design Document (GDD)

## 1. Введение

**Концепция игры:**
"Pixel Runner" — это 2D платформер, в котором игрок управляет персонажем, преодолевающим препятствия в пиксельном мире.

**Жанр и аудитория:**

- **Жанр:** Платформер, аркада
- **Целевая аудитория:** Игроки от 10 лет и старше, любящие ретро-игры

**Платформы:**

- ПК с операционными системами Windows, macOS и Linux

## 2. Игровая механика

**Основные действия игрока:**

- Бег вправо, влево, уклонение от препятствий

**Управление:**

- Движение мышкой

**Правила игры:**

- Игрок должен добраться до конца уровня, избегая препятствий и собирая бонусы

**Система прогресса:**

- Игрок проходит уровни с возрастающей сложностью, собирая очки

## 3. Сюжет и персонажи

**Сюжет:**

- Персонаж путешествует по пиксельному миру, чтобы вернуть украденный артефакт

**Главный персонаж:**

- Маленький квадратик с возможностью бегать

**Противники:**

- Статичные и движущиеся препятствия

## 4. Дизайн уровней

**Общее описание:**

- Игра состоит из 10 уровней, каждый с уникальным дизайном

**Элементы уровней:**

- Подвижные платформы, скрытые проходы, собираемые бонусы

**Прогрессия сложности:**

- Увеличение скорости движения препятствий, добавление новых видов препятствий на более высоких уровнях

## 5. Графика и звук

**Стиль графики:**

- Ретро пиксель-арт с яркими цветами

**Анимации:**

- Бег, падение главного персонажа; анимации препятствий

**Звуковые эффекты:**

- Звук прыжка, сбор бонуса, столкновения с препятствием

**Музыка:**

- Энергичная 8-битная музыка на каждом уровне

## 6. Пользовательский интерфейс (UI)

**Элементы UI:**

- Главное меню с опциями "Начать игру", "Настройки", "Выход"; интерфейс во время игры с отображением очков и количества жизней

**Навигация:**

- Управление в меню с помощью клавиш стрелок и клавиши Enter для выбора

**Отображение информации:**

- Очки и жизни отображаются в верхнем левом углу экрана

## 7. Технические требования

**Платформа и требования к системе:**

- **Платформа:** ПК с Windows 7+, macOS 10.12+, Linux с Python 3.x
- **Минимальные системные требования:** CPU 1.5 ГГц, 2 ГБ ОЗУ, 100 МБ свободного места на диске

**Используемые технологии:**

- Python, библиотека Pygame

**Ограничения:**

- Игра должна работать в разрешении 800x600 пикселей

## 8. Планирование и этапы разработки

**Этапы разработки:**

1. Концептуализация и разработка GDD (1 неделя)
2. Прототипирование основных механик (2 недели)
3. Разработка уровней и контента (3 недели)
4. Тестирование и отладка (1 неделя)

**Сроки:**

- Общая продолжительность проекта — 7 недель

**Ресурсы:**

- 1 программист, 1 художник, доступ к компьютеру с установленным ПО

## 9. Тестирование и обеспечение качества

**План тестирования:**

- Проведение юнит-тестов для основных механик, бета-тестирование с участием группы пользователей

**Критерии успешности:**

- Игра работает без критических ошибок, соответствует описанным в GDD механикам

**Обратная связь:**

- Сбор отзывов через опросы, исправление выявленных проблем

## 10. Приложения

**Эскизы и диаграммы:**

- Эскизы персонажей и уровней

**Списки ресурсов:**

- Перечень необходимых спрайтов и звуковых эффектов

**Ссылки на примеры:**

- Ссылки на классические платформеры для вдохновения

---

# Часть 2: Создание документа SRS для игры (продукта)

## 1. Введение

**Цель документа:**

- Описать архитектуру и проектные решения для разработки 2D игры "Pixel Runner" на Python с использованием Pygame.

**Область применения:**

- Данный документ предназначен для разработчиков, участвующих в создании игры.

**Ссылки:**

- Рефералы на дополнительные материалы или документы не применяются.

## 2. Общее описание системы

**Обзор системы:**

- "Pixel Runner" — это 2D игра, где игрок управляет персонажем, избегает препятствий и стремится набрать максимальное количество очков.

**Архитектурные ограничения:**

- Игра разрабатывается на Python 3 с использованием библиотеки Pygame для отрисовки графики и обработки событий ввода/вывода.

## 3. Архитектурный дизайн

**Архитектурный подход:**

- Архитектура системы основана на объектно-ориентированном подходе, включая использование классов для представления игровых объектов.

**Диаграмма архитектуры:**

- Представление игровых объектов реализовано через классы Player, Obstacle и Sprite в библиотеке Pygame.

## 4. Детальное описание компонентов

**Класс Player:**

- Представляет персонажа, которым управляет игрок. Имеет методы для перемещения персонажа и вызова прыжка.

**Класс Obstacle:**

- Представляет препятствия на пути игрока. Имеет методы для обновления позиции препятствия и его отрисовки на экране.

**Группы спрайтов:**

- Используются для управления и обновления игровых объектов.

## 5. Дизайн данных

**Структуры данных:**

- Используются списки для хранения активных игровых объектов.

**Формат данных:**

- Координаты объектов представлены в виде пар чисел (x, y).

## 6. Интерфейсы системы

**Внутренние интерфейсы:**

- Описаны взаимодействия между классами и модулями.

**Внешние интерфейсы:**

- Игрок взаимодействует с игрой через клавиатуру и мышь.

## 7. Пользовательский интерфейс

**Описание интерфейса:**

- Игровой экран отображает игрока и препятствия. Управление осуществляется с помощью мыши.

## 8. Требования к производительности

**Производительность системы:**

- Игра должна поддерживать стабильную частоту кадров не менее 60 FPS.

**Ограничения ресурсов:**

- Размер используемого приложением оперативного пространства памяти не радикально определен.

## 9. Безопасность

**Обработка ошибок:**

- Требуется обработка исключений, связанных с работой библиотеки Pygame.

**Валидация данных:**

- Введенные данные проверяются на корректность.

## 10. Обеспечение качества

**Стратегия тестирования:**

- План тестирования компонентов игры и критерии приемки еще не определены.

## 11. Требования к среде разработки

**Инструменты разработки:**

- Python 3, Pygame, PyCharm Community Edition.

**Ограничения среды:**

- **Язык программирования:** Python 3
- **Библиотеки:** Pygame

## 12. Приложения

**Диаграммы UML:**

- Диаграммы классов и последовательности будут прикреплены позднее.

**Дополнительные материалы:**

- Дополнительные схемы и таблицы будут прикреплены позднее.

---

# Software Design Document (SDD)

## 1. Введение

Этот документ описывает архитектуру и дизайн игры Pixel Runner, написанной на Python с использованием библиотеки Pygame. Цель игры — управлять персонажем, который должен избегать препятствий, создаваемых в игре, и пытаться набрать максимальное количество очков.

## 2. Описание системы

Игра представляет собой двухмерный платформер, в котором игрок управляет персонажем, перемещая его по горизонтали с помощью мыши. Для того чтобы избежать препятствий, игрок должен прыгать, используя левую кнопку мыши. Препятствия движутся сверху вниз, и если игрок сталкивается с ними, игра заканчивается.

### Основные компоненты игры:

- Игровое окно
- Игрок
- Препятствия
- Система коллизий
- Управление игроком
- Отображение счета
- Графика и анимация

## 3. Функциональные требования

### 3.1 Игрок

- Игрок управляется с помощью мыши.
- Игрок может прыгать, нажав левую кнопку мыши.
- При столкновении с препятствием игра заканчивается, и выводится сообщение с текущим счетом.
- Игрок может перемещаться по экрану только по горизонтали, с ограничениями на край экрана.

### 3.2 Препятствия

- Препятствия падают сверху вниз с случайной горизонтальной позиции.
- Препятствия имеют скорость движения, их скорость можно увеличивать в будущем для усложнения игры.
- Препятствия исчезают, когда выходят за пределы экрана.
- При столкновении с препятствием игра заканчивается.

### 3.3 Управление

- Управление осуществляется движением мыши по горизонтали. Игрок двигается к позиции мыши.
- Прыжок выполняется при нажатии левой кнопки мыши.

### 3.4 Очки

- Игрок получает 1 очко за каждую секунду нахождения в игре.
- При столкновении с препятствием отображается сообщение о конце игры и текущем счете.

## 4. Невыполнимые требования

- Поддержка разных платформ не рассматривается.
- Многопользовательский режим не предусмотрен.
- Звуковое сопровождение и музыка отсутствуют в текущей версии игры.

## 5. Архитектура системы

Игра состоит из нескольких основных классов:

### 5.1 Класс Player

- Хранит состояние игрока.
- Отвечает за движение и прыжки.
- Управляет гравитацией и столкновениями с землей.

```python
class Player(pygame.sprite.Sprite):
    def __init__(self):
        super().__init__()
        self.image = pygame.Surface((50, 50))
        self.image.fill(PLAYER_COLOR)
        self.rect = self.image.get_rect()
        self.rect.center = (WIDTH // 2, HEIGHT - 70)
        self.speed = 5
        self.jump_power = 15
        self.gravity = 1
        self.velocity = 0

    def update(self):
        self.velocity += self.gravity
        self.rect.y += self.velocity

        if self.rect.bottom > HEIGHT - 50:
            self.rect.bottom = HEIGHT - 50
            self.velocity = 0

    def jump(self):
        if self.rect.bottom == HEIGHT - 50:
            self.velocity = -self.jump_power

    def move_to_mouse(self, mouse_x):
        if mouse_x < self.rect.centerx:
            self.rect.x -= self.speed
        elif mouse_x > self.rect.centerx:
            self.rect.x += self.speed

        if self.rect.left < 0:
            self.rect.left = 0
        if self.rect.right > WIDTH:
            self.rect.right = WIDTH
```

## 5.2 Класс Obstacle

Отвечает за создание препятствий и их движение.
Препятствия уничтожаются, когда они выходят за пределы экрана.

```python

class Obstacle(pygame.sprite.Sprite):
def __init__(self):
super().__init__()
self.image = pygame.Surface((30, 30))
self.image.fill(OBSTACLE_COLOR)
self.rect = self.image.get_rect()
self.rect.x = random.randint(0, WIDTH - 30)
self.rect.y = -30
self.speed = 5

    def update(self):
        self.rect.y += self.speed
        if self.rect.top > HEIGHT:
            self.kill()
``` 

## 5.3 Основной игровой цикл

Обрабатывает ввод с клавиатуры и мыши.
Создает новые препятствия по таймеру.
Проверяет столкновения между игроком и препятствиями.
Отображает обновленный экран и счет.

```python
running = True
score = 0
spawn_obstacle = pygame.USEREVENT + 1
pygame.time.set_timer(spawn_obstacle, 1500)

while running:
clock.tick(FPS)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        elif event.type == spawn_obstacle:
            create_obstacle()

    mouse_pos = pygame.mouse.get_pos()
    player.move_to_mouse(mouse_pos[0])

    if pygame.mouse.get_pressed()[0]:
        player.jump()

    all_sprites.update()

    if pygame.sprite.spritecollide(player, obstacles, False):
        print(f"Игра окончена! Ваш счёт: {score}")
        running = False

    score += 1

    screen.fill(WHITE)
    all_sprites.draw(screen)
    pygame.display.flip()

pygame.quit()
```

## 6. Нерешенные проблемы и расширения

   Увеличение сложности игры (ускорение препятствий, уменьшение размеров игрока и т. д.).
   Добавление новых типов препятствий (например, движущихся или с другими поведениями).
   Создание системы уровней.
   Добавление графики и звуков.

## 7. Заключение

   Этот документ описывает ключевые аспекты и архитектуру игры Pixel Runner. Игра состоит из нескольких классов, которые управляют поведением игрока и препятствий. Основной цикл игры отслеживает пользовательский ввод и обновляет состояние экрана, создавая простую и увлекательную игру с базовой механикой.